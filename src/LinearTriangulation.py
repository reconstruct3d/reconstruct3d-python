# Autogenerated with SMOP 
from smop.core import *
# LinearTriangulation.m

    
@function
def LinearTriangulation(K=None,C1=None,R1=None,C2=None,R2=None,x1=None,x2=None,*args,**kwargs):
    varargin = LinearTriangulation.varargin
    nargin = LinearTriangulation.nargin

    ## LinearTriangulation
# Find 3D positions of the point correspondences using the relative
# position of one camera from another
# Inputs:
#     C1 - size (3 x 1) translation of the first camera pose
#     R1 - size (3 x 3) rotation of the first camera pose
#     C2 - size (3 x 1) translation of the second camera
#     R2 - size (3 x 3) rotation of the second camera pose
#     x1 - size (N x 2) matrix of points in image 1
#     x2 - size (N x 2) matrix of points in image 2, each row corresponding
#       to x1
# Outputs: 
#     X - size (N x 3) matrix whos rows represent the 3D triangulated
#       points
    
    P1=dot(dot(K,R1),cat(eye(3),dot(- 1.0,C1)))
# LinearTriangulation.m:18
    P2=dot(dot(K,R2),cat(eye(3),dot(- 1.0,C2)))
# LinearTriangulation.m:19
    X=zeros(length(x1),3)
# LinearTriangulation.m:21
    for i in arange(1,length(x1)).reshape(-1):
        x1p=cat(x1[i,:],1).T
# LinearTriangulation.m:25
        x2p=cat(x2[i,:],1).T
# LinearTriangulation.m:26
        skew1=Vec2Skew(x1p)
# LinearTriangulation.m:28
        skew2=Vec2Skew(x2p)
# LinearTriangulation.m:29
        A=matlabarray(cat([dot(skew1,P1)],[dot(skew2,P2)]))
# LinearTriangulation.m:31
        __,__,v=svd(A,nargout=3)
# LinearTriangulation.m:32
        X[i,:]=v[1:3,end()] / v[end(),end()]
# LinearTriangulation.m:33
    
    
@function
def Vec2Skew(v=None,*args,**kwargs):
    varargin = Vec2Skew.varargin
    nargin = Vec2Skew.nargin

    skew=matlabarray(cat([0,- v[3],v[2]],[v[3],0,- v[1]],[- v[2],v[1],0]))
# LinearTriangulation.m:38